\documentclass[,a4paper,oneside]{article}

\usepackage{tabularx}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{makecell}
\usepackage{xltabular}
\usepackage{xcolor}

\usepackage{minted}
\setminted{
	fontsize=\small,
	baselinestretch=1,
	mathescape=true,
	escapeinside=!!
}


\usepackage[a4paper,left=0.5in,right=1.1in,top=1in,bottom=1in]{geometry}

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\itl}[1]{{\it#1}}
\newcommand{\defeq}{\stackrel{\text{def}}=}
\newcommand{\finmap}{\stackrel{\itl{fin}}\rightharpoonup}
\newcommand{\pset}{{\cal P}}
\newcommand{\idx}[1]{\ensuremath{{}^{#1}}}
\newcommand{\mmdl}{\ensuremath{\mathbb S}}
\newcommand{\nats}{\ensuremath{\mathbb N}}
\newcommand{\rarr}{\ensuremath{\rightarrow}}

\renewcommand\tabularxcolumn[1]{m{#1}}% for vertical centering text in X column

\title{MSc Project Notes}
\author{Opale}

\begin{document}

\maketitle

\section{Memory model constructor cheatsheet}

Note $X^? \defeq X \uplus \bot$, $X^\emptyset \defeq X \uplus \emptyset$

\subsection{Examples per language}

\begin{tabularx}{\textwidth}{l|l}
	\thead{\bfseries Language} & \thead{\bfseries Memory Model}\\ \hline\hline
	WISL & PMap(\itl{Loc}, OneShot(List(Exc(\itl{Val})))) \\ \hline
	JSIL & PMap(\itl{Loc}, PMap(\itl{Str},Exc(\itl{Val$^\emptyset$})) $\otimes$ PMap(\itl{Loc},Ag(\itl{Val}))
\end{tabularx}

\subsection{State Models}

Base building blocks for later transformers. They store values of type $\tau$, usually \itl{Value} or something derived from it. They all define a \code{load} and \code{store} action.

\begin{tabularx}{\textwidth}{l|X|l|l}
	\thead{\bfseries Name} & \thead{\bfseries Purpose} & \thead{\bfseries Type} & \thead{\bfseries Predicates}\\ \hline\hline
	Exc & \small Exclusive ownership of a specific resources & \code{$\tau^?$} & \code{PointsTo}\\\hline
	Ag & \small Multiple parties agree on the same value for a resource & $\tau$ & \code{Agree} \\\hline
	Frac & \small Allow partial (readonly) ownership of an object & $\tau \times (0,1]$& \code{Frac} \\\hline
\end{tabularx} 

\subsection{State Model Transformers}

State model transformers take one or more input state models \mmdl~(and an auxiliary sort I in the case of PMap), and result in a new state model. Here the ``Type'' column only specifies the type of the resulting memory model, the inputs are inferred. $\mmdl.\Sigma$ stands for the heap type of memory model \mmdl.

\begin{tabularx}{\textwidth}{l|X|l|l|l}
	\thead{\bfseries Name} & \thead{\bfseries Purpose} & \thead{\bfseries Type} & \thead{\bfseries Actions} & \thead{\bfseries Predicates}\\ \hline\hline
	Product ($\otimes$) & Two simultaneous states, each being updated separately (eg. List) & $\mmdl_1.\Sigma \times \mmdl_2.\Sigma$ & \multicolumn{2}{l}{lift with \code{A1}, \code{A2}} \\\hline
	Sum ($\oplus$) & Either of two states existing & $\mmdl_1.\Sigma \uplus \mmdl_2.\Sigma$ & \multicolumn{2}{l}{lift with \code{A1}, \code{A2}}\\\hline	
	PMap & \small Define memory as a map of address (a sort~I) to value & $(\text{I}\finmap \mmdl.\Sigma) \times \pset(I)^?$ *\idx1 & \multicolumn{2}{l}{lift with index in-param} \\\hline
	List & \small Ensure continuous memory allocation  & $(\nats \finmap \mmdl.\Sigma) \times \nats^?$ *\idx2 & \multicolumn{2}{l}{lift with index in-param} \\\hline
	Freeable & \small The program only has one go at something (eg. freeing memory) & Exc($\mmdl.\Sigma$) $\oplus$ Exc($\{\varnothing\}$) & \code{free} \\ \hline
\end{tabularx} 

\vspace{1cm}

*\idx1 Full definition: $\left\{ (h,d) \in (\text{I} \finmap \tau )\times \pset(I)^? ~|~ \text{dom}(h)^?\subseteq d\right\}$, with the heap $h$ and $d$ the domain set indicating the non-missing indices.


*\idx2 Full definition: $\left\{ (b, n^?) \in (\mathbb N \finmap \tau) \times \mathbb N^? ~|~ \text{dom}(b) \subseteq [0, n^?)  \right\}$, with $b$ the block and $n$ the size of the block if known.

\clearpage
\section{\code{MonadicSMemory} Functions}

\newcommand{\subcd}[1]{\scriptsize\color[HTML]{777777}\code{#1}}
\newenvironment{subcdd}
  {\par\scriptsize}
  {\par\addvspace{\bigskipamount}}

\newcommand{\rowS}[2]{
    \makecell[l]{\code{#1}} & #2 \\\hline
}
\newcommand{\rowM}[3]{
    \makecell[l]{
      \vspace{-0.1cm}\code{#1}\\\subcd{#2}
    } & #3 \\\hline}
\newcommand{\rowL}[4]{
    \makecell[l]{
      \vspace{-0.1cm}\code{#1}\\
      \vspace{-0.15cm}\subcd{#2}\\\subcd{#3}
     } \par& #4 \\\hline}
\newcommand{\rowXL}[5]{
    \makecell[l]{
      \vspace{-0.1cm}\code{#1}\\
      \vspace{-0.15cm}\subcd{#2}\\\vspace{-0.15cm}\subcd{#3}\\\subcd{#4}
     } & #5 \\\hline}
\newcommand{\qstn}[1]{{\small\color{red}{#1}}}
\newcommand{\unsure}{\qstn{(?)}~}

\begin{xltabular}{\textwidth}{l|X}
	\thead{\bfseries Name/Type} & \thead{\bfseries Description} \\\hline\hline
	   \endhead 
\rowS{type init\_data}{Data needed to initialise the memory model (global context)}
\rowM{type vt}{= SVal.M.t}{Type of GIL Values - always \code{SVal.M}}
\rowM{type st}{= SVal.SESubst.t}{Type of substitutions}
\rowS{type c\_fix\_t}{How to fix missing errors}
\rowS{type err\_t}{Errors encountered (missing, program errors, logical errors)}
\rowS{type t}{State type}
\rowM{type action\_ret}{= (t * vt list, err\_t) result}{Alias for return type of actions/consume}\hline
\rowM{val init}{init\_data -> t}{Construct the state model, with \code{init\_data} obtained from \code{ParserAndCompiler}} 
\rowM{val get\_init\_data}{t -> init\_data}{Returns the \code{init\_data} used to construct this memory model, to avoid having the engine keep track of it} 
\rowM{val clear}{t -> t}{Returns an ``empty'' copy of the state, ie. the state when it is constructed from \code{init\_data}} 
\rowL{val execute\_action}{action\_name:string -> t -> vt list}{-> action\_ret Delayed.t}{Executes a GIL action with given parameters, returns a symbolic outcome} 
\rowL{val consume}{core\_pred:string -> t -> vt list}{-> action\_ret Delayed.t}{Substract the state corresponding to the given core predicate, the given \code{vt list} being the in-params of the predicate, and the \code{vt list} of the returned \code{action\_ret} being the out-params.} 
\rowL{val produce}{core\_pred:string -> t -> vt list}{-> t Delayed.t}{Extend the state with the given core predicate -- \code{vt list} are the in-params AND the out-params of the predicate} 
\rowM{val is\_overlapping\_asrt}{string -> bool}{Always false, to make GIllian handle overlapping equality stuff} 
\rowM{val copy}{t -> t}{Produces a copy of the state (in case it is mutable)} 
\rowM{val pp}{Format.formatter -> t -> unit}{Pretty print the state} 
\rowM{val substitution\_in\_place}{st -> t -> t Delayed.t}{Applies substitution to the state, replacing variables with their values. Not in place.} 
\rowL{val clean\_up}{?keep:Expr.Set.t -> t}{-> Expr.Set.t * Expr.Set.t}{Ignore} 
\rowM{val lvars}{t -> Containers.SS.t}{Returns all logical values in the state to ensure that simplifications don't remove variables we need} 
\rowM{val alocs}{t -> Containers.SS.t}{Returns all the abstract locations in the state -- ignore for now or return recursively} 
\rowL{val assertions}{?to\_keep:Containers.SS.t -> t}{-> Asrt.t list}{Make a list of logical assertions from the state ($\star$, predicates, formulae, typing...). Note sure what \code{to\_keep} is.} 
\rowM{val mem\_constraints}{t -> Formula.t list}{Weird extra well-formedness assertions, that shouldn't matter because they should be handled in \code{produce} anyways.} 
\rowM{val pp\_c\_fix}{Format.formatter -> c\_fix\_t -> unit}{Pretty print fix value} 
\rowM{val get\_recovery\_tactic}{t -> err\_t -> vt Recovery\_tactic.t}{Given a state and error, returns two lists of values that should be folded and unfolded respectively} 
\rowM{val pp\_err}{Format.formatter -> err\_t -> unit}{Pretty print error} 
\rowM{val get\_failing\_constraint}{err\_t -> Formula.t}{A formula that must be satisfied to avoid causing the given error \unsure} 
\rowXL{val get\_fixes}{t -> PFS.t -> Type\_env.t -> err\_t}{-> (c\_fix\_t list * Formula.t list *}{(string * Type.t) list * Containers.SS.t) list}{\qstn{???}} 
\rowM{val can\_fix}{err\_t -> bool}{If an error is fixable (if missing)} 
\rowL{val apply\_fix}{t -> c\_fix\_t}{-> (t, err\_t) result Delayed.t}{Apply a given fix to a state, possibly resulting in a new error} 
\rowL{val pp\_by\_need}{Containers.SS.t -> Format.formatter}{-> t -> unit}{Pretty print the state \unsure} 
\rowL{val get\_print\_info}{Containers.SS.t -> t}{-> Containers.SS.t * Containers.SS.t}{\qstn{Given ? and a state, returns a tuple of ? and ? to print}} 
\rowM{val sure\_is\_nonempty}{t -> bool}{If this state fragment is empty - can be over-approximated to always be \code{false}} 
\rowL{val split\_further}{t -> string -> vt list -> err\_t}{-> (vt list list * vt list) option}{If an error occurred when trying to split a core predicate, offers a new way of splitting it, with a list of ins and ways of learning the outs. Related to wands. Can always return None} 
\end{xltabular}

\section{Mismatches}

Differences between the theory and what is implemented in Gillian.

\begin{tabularx}{\textwidth}{X|X}
	\thead{\bfseries Theory} & \thead{\bfseries Gillian} \\ \hline\hline
\code{val eval\_action :\newline ${\cal A}\rarr\Sigma\rarr \textrm{\it Val}$ list $\rarr ({\cal O}\times \textrm{\it Val} \times \Sigma)$ set}
	& \small\code{val execute\_action :\newline
    string $\rarr$ t $\rarr$ vt list $\rarr$ action\_ret Delayed.t}
    with \code{action\_ret = (t * vt list, err\_t) result} (note \code{vt list}, rather than \code{vt})
    \\\hline
    \code{produce }$\sigma ~\delta ~\vec{v_i}~\vec{v_o} = \{ \sigma\cdot\sigma_\delta ~|~\sigma_\delta \vDash \left<\delta\right> (\vec{v_i}, \vec{v_o}) \}$, ie.\newline
    \small\code{val produce :}\newline
    \code{$\Sigma\rarr\Delta \rarr \textrm{\it Val}$ list $\rarr \textrm{\it Val}$ list $\rarr \Sigma$ list}
    & \small\code{val produce :\newline core\_pred:string $\rarr$ t $\rarr$ vt list $\rarr$ t Delayed.t} (note there is only one \code{vt list} input, for $\vec{v_i}$)
    
\end{tabularx}

\clearpage

\section{Emptiness in state models}

\subsection{Current State}

There exists a source of unsoundness in the current definition of state models, related to the representation of empty states, as there may exist multiple different observably empty states, leading to composition rules being unsound if not accounted for.

To demonstrate this, we may consider the Freeable state. It is defined as:

\newcommand{\val}[0]{\textit{Val}~}

\begin{align*}
	\text{Freeable}(X) &\defeq \bot ~|~ \varnothing ~|~ \val X\\
	\text{\underline{Freeable}}(X) &\defeq \varnothing ~|~\val X
\end{align*}

With composition:
\begin{align*}
	f \cdot \bot &= f\\
	\bot \cdot f &= f\\
	\val f_1 \cdot \val f_2 &= \val (f_1\cdot f_2)\\
\end{align*}

This forms a valid partially commutative monoid (PCM). We may now look at an example of using this state model that proves to be unsound. Assume the state model PMap(\nats, Freeable(Exc)), with PMap representing a partial map, that is initially with no mappings, []. We omit the domain set for brevity.

\newcommand{\corepred}[3]{\ensuremath{\left<\texttt{#1}\right>(#2;#3)}}

\begin{table}[h]\centering
\begin{tabular}{l|l}
 State & Operation applied \\ \hline 
 $\bot$ & Initial State\\
 0 $\mapsto \val a$ & Produce \corepred{PointsTo}{0}{a} \\
 0 $\mapsto \val \bot$ & Consume \corepred{PointsTo}{0}{a} \\
 undefined! & Produce \corepred{Free}{0}{}
\end{tabular}
\end{table}

This is, of course, unsound, as the state at the end should indeed be $0 \mapsto \varnothing$. This is due to the fact what is effectively an empty state, $\val \bot$, is different from the Freeable empty state, $\bot$, rendering the composition $\val \bot \cdot \varnothing$ undefined.  Note that consuming \code{PointsTo} doesn't result in a $0\mapsto \bot$ state, as PMap must pass consumption down, and so must Freeable, as neither are ``aware'' of the meaning of \code{PointsTo}.

To fix this, Freeable would need to be able to know if its contents are observably empty after consuming a predicate, and if so become $\bot$. This seems to hint at a definition or property of our state models missing.

This error can also be shown to exist in the implementation itself, by writing a specification with \code{True} as the precondition, \code{False} as the postcondition.

\begin{minted}{text}
spec free_cell(x)
  [[ (x == #x) * <points_to>(#x;#anything) ]]
  [[ (ret == null) * <freed>(#x;) ]]
  normal
proc free_cell(x) {
  n := [free](x);
  ret := null;
  return
};

spec test_unsoundness()
  [[ True ]]
  [[ False ]]
  normal
proc test_unsoundness() {
  x := [alloc]();
  x := l-nth(x, 0i);
  n := "free_cell"(x);
  ret := null;
  return
};
\end{minted}

This GIL code is then succesfuly verified, with the following output.

\begin{minted}{text}
Parsing and compiling...
Preprocessing...
Obtaining specs to verify...
Obtaining lemmas to verify...
Obtained 2 symbolic tests in total
Running symbolic tests: 0.002729
Verifying one spec of procedure free_cell... s Success
Verifying one spec of procedure test_unsoundness... Success
All specs succeeded: 0.004729	
\end{minted}


\subsection{Proof of Unsoundness}

First we may take a look at the rules consumers and producers must follow to be sound. Given a set of core predicates $(\Delta\ni\delta, \vDash)$:

\newcommand{\ins}[0]{\vec{v_i}}
\newcommand{\outs}[0]{\vec{v_o}}

\begin{gather*}
	\code{produce }\sigma ~\delta ~\ins~\outs = \{\sigma \cdot \sigma_\delta ~|~\sigma_\delta \vDash \corepred{$\delta$}{\ins}{\outs}, ~\sigma\#\sigma_\delta\}
\end{gather*}
\begin{gather*}
	\sigma.\code{consume}_\delta(\ins)\rarr \code{Ok}:(\outs,\sigma')\\
	\Longrightarrow\exists\sigma_\delta .\sigma=\sigma'\cdot \sigma_\delta\land \sigma_\delta\vDash\corepred{$\delta$}{\ins}{\outs}
\end{gather*}

The \code{produce} rule in particular states that the result of \code{produce} must be the given state extended by all disjoint resources that could be associated to a given core predicate.

Freeable(X) being a derivative of a sum state model (in the form of X $\oplus$ Freed), and similar unsoundness being present in the sum state model, we may look at what property sum breaks to exhibit such unsoundness. First, we may have take a look at how sum is originally defined.

The sum $\mmdl.1 \oplus \mmdl.2$ is defined as \code{type $\Sigma$ = $\bot_\oplus$ | S1 of $\mathbb S_1.\Sigma$ | S2 of $\mathbb S_2.\Sigma$}, with the following composition rules and \code{produce} implementation (note we annotate the sum's $\bot$ element as $\bot_\oplus$ to later distinguish it from the $\bot$ of other state models):

\begin{align*}
	\sigma \cdot \bot_\oplus=\bot_\oplus\cdot\sigma&=\sigma\\
	(\code{S}_1~\sigma_1)\cdot(\code S_1~\sigma_1') &= \code S_1~(\sigma_1\cdot \sigma_1')\\
	(\code{S}_2~\sigma_2)\cdot(\code S_2~\sigma_2') &= \code S_2~(\sigma_2\cdot \sigma_2')\\
	\text{undefined}&\text{ otherwise}
\end{align*}


\begin{minted}{ocaml}
produce !$\sigma$! !$\delta$! !$\ins$! !$\outs$! =
    match !$\sigma$!, !$\delta$! with
    | S1 !$\sigma_1$!, P1 !$\delta_1$! -> 
        let* !$\delta_1'$! = produce !$\sigma_1$! !$\delta_1$! !$\ins$! !$\outs$! in
        S1 !$\delta_1'$!
    | !$\bot_\oplus$!, P1 !$\delta_1$! ->
    	let* !$\delta_1'$! = produce !$\mmdl_1.0$! !$\delta_1$! !$\ins$! !$\outs$! in
        S1 !$\delta_1'$!
    | S2 !$\sigma_2$!, P2 !$\delta_2$! -> 
        let* !$\delta_2'$! = produce !$\sigma_2$! !$\delta_2$! !$\ins$! !$\outs$! in
        S2 !$\delta_2'$!
    | !$\bot_\oplus$!, P2 !$\delta_2$! -> 
        let* !$\delta_2'$! = produce !$\mmdl_2.0$! !$\delta_2$! !$\ins$! !$\outs$! in
        S2 !$\delta_2'$!
    | _, _ -> vanish
\end{minted}

This function simply dispatches the predicate to the corresponding state model, default to the relevant empty state if needed, and vanishes if a mismatch occurs (for either \code{S1 $\sigma_1$, P2 $\delta_2$} or \code{S2 $\sigma_2$, P1 $\delta_1$}).

Now, let there be a state model $A$ that defines a bottom element $\bot_A$, such that $\forall \sigma.~\sigma \cdot\bot_A = \sigma$, and a second state model $B$. Given the state model $A\oplus B$, and the above implementation of \code{produce}, we get the following results:

\begin{align}
	\code{produce}~\sigma~\delta~\ins~\outs = \begin{cases}
		\code{produce}~\sigma_A~\delta_A~\ins~\outs 
			& \text{if }\delta=\code{P1}~\delta_A\land\sigma=\code{S1}~\sigma_A\\
		\code{produce}~A.0~\delta_A~\ins~\outs 
			& \text{if }\delta=\code{P1}~\delta_A\land\sigma=\bot_\oplus\\
		\code{produce}~\sigma_B~\delta_B~\ins~\outs 
			& \text{if }\delta=\code{P2}~\delta_B\land\sigma=\code{S2}~\sigma_B\\
		\code{produce}~B.0~\delta_B~\ins~\outs 
			& \text{if }\delta=\code{P2}~\delta_B\land\sigma=\bot_\oplus\\
		\emptyset & \text{otherwise}
	\end{cases}
\end{align}

Let the current state be $\code{S1}~\bot_A$. As $\bot_A$ is the empty state for the $A$ memory model, it is disjoint from any other state. Given a core predicate $\delta_B$ and its ins and outs, there may exist a state $\sigma_B$ such that $\sigma_B\vDash \corepred{$\delta_B$}{\ins}{\outs}$ and we know that $\bot_A \# \sigma_B$. 

As such, we would expect $\code{produce}~\code{S1}~\bot_A~\delta_B~\ins~\outs = \{\code{S2}~\sigma_B~|~\sigma_B\in \code{produce}~B.0~ \delta_B~\ins~\outs \}$, however that is not the case:

\begin{align*}
	\code{produce}~(\code{S1}~\bot_A)~\delta_B~\ins~\outs
	&=\{\code{S1}~\bot_A\cdot\code{S2}~\sigma_{\delta_B}~|~\sigma_{\delta_B}\vDash\corepred{$\delta$}{\ins}{\outs},\bot_A\#\sigma_{\delta_B}\}&\text{from core predicates producers rule}\\
	&=\emptyset &\text{as }\code{S1}~\sigma_A\cdot\code{S2}~\sigma_B\text{ is undefined}\\~\\
	~
	\nexists \delta.~\code{produce}~\sigma~\delta~\ins~\outs\not\subseteq \{\sigma\}\\
	\text{ie. }\forall \delta.~\code{produce}~\sigma~\delta~\ins~\outs\subset\{\sigma\}
\end{align*}

For the result of \code{produce} to match what's expected, new rules would need to be added to composition and produce to handle \code{S1~$\bot_A$} in the same way it handles $\bot_\oplus$. However there currently is no way of doing this, as the existence of an empty element in $A$ or $B$ is not exposed -- while some state models (like Exc) may have one, others (like Ag) may not.

\subsection{Sound Emptiness}

A fix to this is to define a ``global'' emptiness, that replaces the different ``local'' empty states each state model may define. Consuming a predicate, or executing an action, may result in a new state {\it or} a global $\bot$. This forces state model transformers to handle such empty states, and ensures a state becoming empty deep within a now-observably-empty construction will naturally unwrap into a shallow empty. We also lift the composition operation defined by state models to handle $\bot$: $a \cdot \bot = \bot \cdot a = a$.

A side-effect of this is that a non-$\bot$ state is never considered observably-empty, as otherwise it would be $\bot$ -- this allows us to remove the \code{is\_empty} function that was used for some optimisations, as it is sufficient to compare a given state with $\bot$.

An advantage of this approach is that lifting a full state model to a complete state model doesn't require anything (aside from handling $\bot$ in \code{produce} and \code{consume}), as the empty compositional state is already added!

We now redefine some of the constructs used in the engine according to this new definition.

\newcommand{\vallist}[0]{\textit{Val}~\code{list}}

\begin{gather*}
	\Sigma^? \defeq \Sigma \uplus \bot\\
	\code{consume}:\Sigma \rarr \Delta \rarr \vallist \rarr (\mathcal O^+_l \times \vallist \times \Sigma^?) \\
	\code{produce}:\Sigma^? \rarr \Delta \rarr \vallist \rarr \vallist \rarr \Sigma~\code{set}\\
	\code{eval\_action}: {\cal A} \rarr \Sigma^? \rarr \vallist \rarr (\mathcal O^+_l \times \vallist \times \Sigma^?)
\end{gather*}

A consideration with this is that \code{consume} only works on non-$\bot$ elements, as no predicate is satisfied by the empty state (not sure about this). For produce however, a predicate can be produced from the absence of state.

We may now redefine some of the state models with this new idea.

\subsubsection{State Sum}

A state sum $\mathbb S_1 \oplus \mathbb S_2$ is now defined as \code{type $\Sigma$ = S1 of $\mathbb S_1.\Sigma$ | S2 of $\mathbb S_2.\Sigma$}. We define composition and \code{produce} as follows:

\begin{align*}
	(\code{S1 }\sigma)\cdot(\code{S1 }\sigma') &= \code{S1 }(\sigma\cdot\sigma')\\
	(\code{S2 }\sigma)\cdot(\code{S2 }\sigma') &= \code{S2 }(\sigma\cdot\sigma')\\
	\text{undefined}&\text{ otherwise}
\end{align*}

\begin{minted}{ocaml}
produce !$\sigma^?$! !$\delta$! !$\ins$! !$\outs$! =
    match !$\sigma^?$!, !$\delta$! with
    | S1 !$\sigma_1$!, P1 !$\delta_1$! -> 
        let* !$\delta_1'$! = produce !$\sigma_1$! !$\delta_1$! !$\ins$! !$\outs$! in
        S1 !$\delta_1'$!
    | !$\bot$!, P1 !$\delta_1$! ->
    	let* !$\delta_1'$! = produce !$\mmdl_1.0$! !$\delta_1$! !$\ins$! !$\outs$! in
        S1 !$\delta_1'$!
    | S2 !$\sigma_2$!, P2 !$\delta_2$! -> 
        let* !$\delta_2'$! = produce !$\sigma_2$! !$\delta_2$! !$\ins$! !$\outs$! in
        S2 !$\delta_2'$!
    | !$\bot$!, P2 !$\delta_2$! -> 
        let* !$\delta_2'$! = produce !$\mmdl_2.0$! !$\delta_2$! !$\ins$! !$\outs$! in
        S2 !$\delta_2'$!
    | _, _ -> vanish
\end{minted}


\end{document}