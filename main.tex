\documentclass[,a4paper,oneside]{article}

\usepackage{tabularx}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{makecell}
\usepackage{xltabular}
\usepackage{xcolor}

\usepackage[a4paper,left=0.5in,right=1.1in,top=1in,bottom=1in]{geometry}

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\itl}[1]{{\it#1}}
\newcommand{\defeq}{\stackrel{\text{def}}=}
\newcommand{\finmap}{\stackrel{\itl{fin}}\rightharpoonup}
\newcommand{\pset}{{\cal P}}
\newcommand{\idx}[1]{\ensuremath{{}^{#1}}}
\newcommand{\mmdl}{\ensuremath{\mathbb S}}
\newcommand{\nats}{\ensuremath{\mathbb N}}
\newcommand{\rarr}{\ensuremath{\rightarrow}}

\renewcommand\tabularxcolumn[1]{m{#1}}% for vertical centering text in X column

\title{MSc Project Notes}
\author{Opale}

\begin{document}

\maketitle

\section{Memory model constructor cheatsheet}

Note $X^? \defeq X \uplus \bot$, $X^\emptyset \defeq X \uplus \emptyset$

\subsection{Examples per language}

\begin{tabularx}{\textwidth}{l|l}
	\thead{\bfseries Language} & \thead{\bfseries Memory Model}\\ \hline\hline
	WISL & PMap(\itl{Loc}, OneShot(List(Exc(\itl{Val})))) \\ \hline
	JSIL & PMap(\itl{Loc}, PMap(\itl{Str},Exc(\itl{Val$^\emptyset$})) $\otimes$ PMap(\itl{Loc},Ag(\itl{Val}))
\end{tabularx}

\subsection{State Models}

Base building blocks for later transformers. They store values of type $\tau$, usually \itl{Value} or something derived from it. They all define a \code{load} and \code{store} action.

\begin{tabularx}{\textwidth}{l|X|l|l}
	\thead{\bfseries Name} & \thead{\bfseries Purpose} & \thead{\bfseries Type} & \thead{\bfseries Predicates}\\ \hline\hline
	Exc & \small Exclusive ownership of a specific resources & \code{$\tau^?$} & \code{PointsTo}\\\hline
	Ag & \small Multiple parties agree on the same value for a resource & $\tau$ & \code{Agree} \\\hline
	Frac & \small Allow partial (readonly) ownership of an object & $\tau \times (0,1]$& \code{Frac} \\\hline
\end{tabularx} 

\subsection{State Model Transformers}

State model transformers take one or more input state models \mmdl~(and an auxiliary sort I in the case of PMap), and result in a new state model. Here the ``Type'' column only specifies the type of the resulting memory model, the inputs are inferred. $\mmdl.\Sigma$ stands for the heap type of memory model \mmdl.

\begin{tabularx}{\textwidth}{l|X|l|l|l}
	\thead{\bfseries Name} & \thead{\bfseries Purpose} & \thead{\bfseries Type} & \thead{\bfseries Actions} & \thead{\bfseries Predicates}\\ \hline\hline
	Product ($\otimes$) & Two simultaneous states, each being updated separately (eg. List) & $\mmdl_1.\Sigma \times \mmdl_2.\Sigma$ & \multicolumn{2}{l}{lift with \code{A1}, \code{A2}} \\\hline
	Sum ($\oplus$) & Either of two states existing & $\mmdl_1.\Sigma \uplus \mmdl_2.\Sigma$ & \multicolumn{2}{l}{lift with \code{A1}, \code{A2}}\\\hline	
	PMap & \small Define memory as a map of address (a sort~I) to value & $(\text{I}\finmap \mmdl.\Sigma) \times \pset(I)^?$ *\idx1 & \multicolumn{2}{l}{lift with index in-param} \\\hline
	List & \small Ensure continuous memory allocation  & $(\nats \finmap \mmdl.\Sigma) \times \nats^?$ *\idx2 & \multicolumn{2}{l}{lift with index in-param} \\\hline
	OneShot & \small The program only has one go at something (eg. freeing memory) & Exc($\mmdl.\Sigma$) $\oplus$ Exc($\{\varnothing\}$) & \code{free} \\ \hline
\end{tabularx} 

\vspace{1cm}

*\idx1 Full definition: $\left\{ (h,d) \in (\text{I} \finmap \tau )\times \pset(I)^? ~|~ \text{dom}(h)^?\subseteq d\right\}$, with the heap $h$ and $d$ the domain set indicating the non-missing indices.


*\idx2 Full definition: $\left\{ (b, n^?) \in (\mathbb N \finmap \tau) \times \mathbb N^? ~|~ \text{dom}(b) \subseteq [0, n^?)  \right\}$, with $b$ the block and $n$ the size of the block if known.

\clearpage
\section{\code{MonadicSMemory} Functions}

\newcommand{\subcd}[1]{\scriptsize\color[HTML]{777777}\code{#1}}
\newenvironment{subcdd}
  {\par\scriptsize}
  {\par\addvspace{\bigskipamount}}

\newcommand{\rowS}[2]{
    \makecell[l]{\code{#1}} & #2 \\\hline
}
\newcommand{\rowM}[3]{
    \makecell[l]{
      \vspace{-0.1cm}\code{#1}\\\subcd{#2}
    } & #3 \\\hline}
\newcommand{\rowL}[4]{
    \makecell[l]{
      \vspace{-0.1cm}\code{#1}\\
      \vspace{-0.15cm}\subcd{#2}\\\subcd{#3}
     } \par& #4 \\\hline}
\newcommand{\rowXL}[5]{
    \makecell[l]{
      \vspace{-0.1cm}\code{#1}\\
      \vspace{-0.15cm}\subcd{#2}\\\vspace{-0.15cm}\subcd{#3}\\\subcd{#4}
     } & #5 \\\hline}
\newcommand{\qstn}[1]{{\small\color{red}{#1}}}
\newcommand{\unsure}{\qstn{(?)}~}

\begin{xltabular}{\textwidth}{l|X}
	\thead{\bfseries Name/Type} & \thead{\bfseries Description} \\\hline\hline
	
\rowS{type init\_data}{Data needed to initialise the memory model}
\rowM{type vt}{= SVal.M.t}{Type of GIL Values - \qstn{Any reason for this to not always be SVal.M?}}
\rowM{type st}{= SVal.SESubst.t}{Type of substitutions}
\rowS{type c\_fix\_t}{How to fix missing errors}
\rowS{type err\_t}{Errors encountered (missing, program errors, logical errors)}
\rowS{type t}{State type}
\rowM{type action\_ret}{= (t * vt list, err\_t) result}{Alias for return type of actions/consume}\hline
\rowM{val init}{init\_data -> t}{Construct the state model \qstn{initdata obtained from ParserAndCompiler?}} 
\rowM{val get\_init\_data}{t -> init\_data}{Returns the \code{init\_data} used to construct this memory model \qstn{What's the use? CTRL+F makes it seem it's never used}} 
\rowM{val clear}{t -> t}{Returns an ``empty'' copy of the state \unsure} 
\rowL{val execute\_action}{action\_name:string -> t -> vt list}{-> action\_ret Delayed.t}{Executes a GIL action with given parameters, returns a symbolic outcome} 
\rowL{val consume}{core\_pred:string -> t -> vt list}{-> action\_ret Delayed.t}{Substract the state corresponding to the given core predicate, \code{vt list} being the in-params of the predicate} 
\rowL{val produce}{core\_pred:string -> t -> vt list}{-> t Delayed.t}{Extend the state with the given core predicate -- \code{vt list} are the in-params \unsure of the predicate} 
\rowM{val is\_overlapping\_asrt}{string -> bool}{\qstn{If the given assertion predicate name is used/overlaps/is needed by a state?}} 
\rowM{val copy}{t -> t}{Produces a copy of the state (in case it is mutable)} 
\rowM{val pp}{Format.formatter -> t -> unit}{Pretty print the state} 
\rowM{val substitution\_in\_place}{st -> t -> t Delayed.t}{Applies substitution to the state, replacing variables with their values.} 
\rowL{val clean\_up}{?keep:Expr.Set.t -> t}{-> Expr.Set.t * Expr.Set.t}{\qstn{Given a set of expressions that must be kept, and a state, returns a tuple (expressions that can be ignored, expressions to keep)? Can be under-approximated and always return (empty, keep)?}} 
\rowM{val lvars}{t -> Containers.SS.t}{Returns all logical values in the state \unsure \qstn{What for?}} 
\rowM{val alocs}{t -> Containers.SS.t}{Returns all the abstract locations in the state \qstn{Abstract location?}} 
\rowL{val assertions}{?to\_keep:Containers.SS.t -> t}{-> Asrt.t list}{Make a list of logical assertions from the state ($\star$, predicates, formulae, typing...) \qstn{What is \code{to\_keep}?}} 
\rowM{val mem\_constraints}{t -> Formula.t list}{\qstn{Well-formedness constraints on the memory? If so why does GillianC define it as always being \code{[]}?}} 
\rowM{val pp\_c\_fix}{Format.formatter -> c\_fix\_t -> unit}{Pretty print fix value} 
\rowM{val get\_recovery\_tactic}{t -> err\_t -> vt Recovery\_tactic.t}{Given a state and error, returns two lists of values that should be folded and unfolded respectively} 
\rowM{val pp\_err}{Format.formatter -> err\_t -> unit}{Pretty print error} 
\rowM{val get\_failing\_constraint}{err\_t -> Formula.t}{A formula that must be satisfied to avoid causing the given error \unsure} 
\rowXL{val get\_fixes}{t -> PFS.t -> Type\_env.t -> err\_t}{-> (c\_fix\_t list * Formula.t list *}{(string * Type.t) list * Containers.SS.t) list}{\qstn{???}} 
\rowM{val can\_fix}{err\_t -> bool}{If an error is fixable} 
\rowL{val apply\_fix}{t -> c\_fix\_t}{-> (t, err\_t) result Delayed.t}{Apply a given fix to a state, possibly resulting in a new error} 
\rowL{val pp\_by\_need}{Containers.SS.t -> Format.formatter}{-> t -> unit}{Pretty print the state \unsure} 
\rowL{val get\_print\_info}{Containers.SS.t -> t}{-> Containers.SS.t * Containers.SS.t}{\qstn{Given ? and a state, returns a tuple of ? and ? to print}} 
\rowM{val sure\_is\_nonempty}{t -> bool}{If this state fragment is empty - can be over-approximated to always be \code{false}} 
\rowL{val split\_further}{t -> string -> vt list -> err\_t}{-> (vt list list * vt list) option}{If an error occurred when trying to split a core predicate, offers a new way of splitting it, with a list of ins and ways of learning the outs.} 
\end{xltabular}

\section{Mismatches}

Differences between the theory and what is implemented in Gillian.

\begin{tabularx}{\textwidth}{X|X}
	\thead{\bfseries Theory} & \thead{\bfseries Gillian} \\ \hline\hline
\code{val eval\_action :\newline ${\cal A}\rarr\Sigma\rarr \textrm{\it Val}$ list $\rarr ({\cal O}\times \textrm{\it Val} \times \Sigma)$ set}
	& \small\code{val execute\_action :\newline
    string $\rarr$ t $\rarr$ vt list $\rarr$ action\_ret Delayed.t}
    with \code{action\_ret = (t * vt list, err\_t) result} (note \code{vt list}, rather than \code{vt})
    \\\hline
    \code{produce }$\sigma ~\delta ~\vec{v_i}~\vec{v_o} = \{ \sigma\cdot\sigma_\delta ~|~\sigma_\delta \vDash \left<\delta\right> (\vec{v_i}, \vec{v_o}) \}$, ie.\newline
    \small\code{val produce :}\newline
    \code{$\Sigma\rarr\Delta \rarr \textrm{\it Val}$ list $\rarr \textrm{\it Val}$ list $\rarr \Sigma$ list}
    & \small\code{val produce :\newline core\_pred:string $\rarr$ t $\rarr$ vt list $\rarr$ t Delayed.t} (note there is only one \code{vt list} input, for $\vec{v_i}$)
    
\end{tabularx}

\end{document}